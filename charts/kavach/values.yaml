# Default values for kavach.
# Declare variables to be passed into your templates.

nameOverride: kavach
fullnameOverride: kavach

## Override the deployment namespace
namespaceOverride: dega

imagePullSecrets: []

global:
  image:
    tag: ""
    imagePullPolicy: IfNotPresent
  securityContext: {}
    # runAsUser: 999
    # runAsGroup: 999
    # fsGroup: 999

server:
  name: server

  image:
    repository: factly/kavach-server
    pullPolicy: IfNotPresent
    tag: ""

  # imagePullSecrets: []

  # This value will be ignored if Autoscaling is enabled
  replicaCount: 1

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 5
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  autoMigrate: false

  ## Environment variables to pass to kavach Server
  env: {}
    # Setup IMGPROXY usage within the cluster
    # - name: KAVACH_IMAGEPROXY_URL
    #   value: "https://images.factly.org"
    # - name: KAVACH_MODE
    #   value: "development"
    # - name: KAVACH_KETO_URL
    #   value: "http://keto.dega.svc.cluster.local:4466"
    # - name: KAVACH_DATABASE_HOST
    #   value: "kavach-postgresql.dega.svc.cluster.local"
    # - name: KAVACH_DATABASE_NAME
    #   value: "kavach"
    # - name: KAVACH_DATABASE_PORT
    #   value: "5432"
    # - name: KAVACH_DATABASE_USER
    #   value: "postgres"    
    # - name: KAVACH_DATABASE_PASSWORD
    #   valueFrom:
    #     secretKeyRef:
    #       name: kavach-server
    #       key: database_password
    # - name: KAVACH_DATABASE_SSL_MODE
    #   value: "disable"
    # - name: KAVACH_SENDGRID_API_KEY
    #   valueFrom:
    #     secretKeyRef:
    #       name: sendgrid
    #       key: kavach        
    # - name: KAVACH_DOMAIN_NAME
    #   value: "https://kavach.factly.org"      

  serviceAccount:
    # Specifies whether a service account should be created
    create: false
    # Annotations to add to the service account
    annotations: {}
    # Labels to add to the service account
    labels: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: "kavach-server"

  podAnnotations: {}

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  configAnnotations: {}

  service:
    type: ClusterIP
    port: 8000
    portName: http
    annotations: {}
    labels: {}

  metrics:
    enabled: false

    service:
      type: ClusterIP
      port: 8001
      portName: metrics
      annotations: {}
      labels: {}

    serviceMonitor:
      enabled: false
      selector:
        # prometheus: kube-prometheus
        release: monitoring
      labels: {}
      interval: 30s

      scheme: http
      tlsConfig: {}
      scrapeTimeout: 30s
      relabelings: []    

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.

    # limits:
    #   cpu: 500m
    #   memory: 1024Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  ## Readiness and liveness probes for default backend
  ## Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/
  ##
  readinessProbe:
    initialDelaySeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
    periodSeconds: 10
  livenessProbe:
    initialDelaySeconds: 50
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
    periodSeconds: 10

  nodeSelector: {}

  tolerations: []

  affinity: {}

web:
  name: web

  image:
    repository: factly/kavach-web
    pullPolicy: IfNotPresent
    tag: ""

  # imagePullSecrets: []

  # This value will be ignored if Autoscaling is enabled
  replicaCount: 1

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 5
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  ## Environment variables to pass to kavach web
  env: {}
    # - name: PUBLIC_URL
    #   value: "https://kavach.factly.org"
    # - name: REACT_APP_KAVACH_TITLE
    #   value: "NEDC"
    # - name: REACT_APP_COMPANION_URL
    #   value: "https://companion.factly.org"
    # - name: REACT_APP_API_URL
    #   value: "https://kavach-server.factly.org"      
    # - name: REACT_APP_KRATOS_PUBLIC_URL
    #   value: "https://kratos.factly.org"
    # - name: REACT_APP_LOGO_URL
    #   value: "https://storage.googleapis.com/kavach/nedc-logo.png"

  serviceAccount:
    # Specifies whether a service account should be created
    create: false
    # Annotations to add to the service account
    annotations: {}
    # Labels to add to the service account
    labels: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: "kavach-web"

  podAnnotations: {}

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  configAnnotations: {}

  service:
    # type: ClusterIP
    type: NodePort
    port: 80
    portName: http
    annotations: {}
    labels: {}

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 500m
    #   memory: 1024Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  ## Readiness and liveness probes for default backend
  ## Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/
  ##
  readinessProbe:
    initialDelaySeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
    periodSeconds: 10
  livenessProbe:
    initialDelaySeconds: 50
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
    periodSeconds: 10

  nodeSelector: {}

  tolerations: []

  affinity: {}

postgresql:
  enabled: false


minio:
  enabled: false

  ## minio server mode, i.e. standalone or distributed.
  ## Distributed Minio ref: https://docs.minio.io/docs/distributed-minio-quickstart-guide
  ##
  # mode: standalone
  mode: distributed

  ## Update strategy for Deployments
  DeploymentUpdate:
    type: RollingUpdate
    maxUnavailable: 0
    maxSurge: 100%

  ## Update strategy for StatefulSets
  StatefulSetUpdate:
    updateStrategy: RollingUpdate

  ## Use existing Secret that store following variables:
  ##
  ## | Chart var             | .data.<key> in Secret    |
  ## |:----------------------|:-------------------------|
  ## | accessKey             | accesskey                |
  ## | secretKey             | secretkey                |
  ## | gcsgateway.gcsKeyJson | gcs_key.json             |
  ## | s3gateway.accessKey   | awsAccessKeyId           |
  ## | s3gateway.secretKey   | awsSecretAccessKey       |
  ## | etcd.clientCert       | etcd_client_cert.pem     |
  ## | etcd.clientCertKey    | etcd_client_cert_key.pem |
  ##
  ## All mentioned variables will be ignored in values file.
  ## .data.accesskey and .data.secretkey are mandatory,
  ## others depend on enabled status of corresponding sections.
  existingSecret: "minio"

  # Number of MinIO containers running
  replicas: 4
  # Number of expanded MinIO clusters
  zones: 1

  ## Enable persistence using Persistent Volume Claims
  ## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
  ##
  persistence:
    enabled: true

    ## A manually managed Persistent Volume and Claim
    ## Requires persistence.enabled: true
    ## If defined, PVC must be created manually before volume will be bound
    existingClaim: ""

    ## minio data Persistent Volume Storage Class
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
    ##   GKE, AWS & OpenStack)
    ##
    ## Storage class of PV to bind. By default it looks for standard storage class.
    ## If the PV uses a different storage class, specify that here.
    storageClass: ""
    VolumeName: ""
    accessMode: ReadWriteOnce
    size: 10Gi

    ## If subPath is set mount a sub folder of a volume instead of the root of the volume.
    ## This is especially handy for volume plugins that don't natively support sub mounting (like glusterfs).
    ##
    subPath: ""

  ## Expose the Minio service to be accessed from outside the cluster (LoadBalancer service).
  ## or access it from within the cluster (ClusterIP service). Set the service type and the port to serve it.
  ## ref: http://kubernetes.io/docs/user-guide/services/
  ##

  service:
    type: ClusterIP
    clusterIP: ~
    port: 9000
    nodePort: 32000

    ## List of IP addresses at which the Prometheus server service is available
    ## Ref: https://kubernetes.io/docs/user-guide/services/#external-ips
    ##
    externalIPs: []
    #   - externalIp1

    annotations: {}
      # prometheus.io/scrape: 'true'
      # prometheus.io/path:   '/minio/prometheus/metrics'
      # prometheus.io/port:   '9000'


  ## Node labels for pod assignment
  ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}
  tolerations: []
  affinity: {}

  # Additational pod annotations
  podAnnotations: {}

  # Additional pod labels
  podLabels: {}

  ## Configure resource requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources:
    requests:
    memory: 1Gi
    cpu: 250m
  limits:
    memory: 4Gi
    cpu: 1

  ## Create a bucket after minio install
  ##
  defaultBucket:
    enabled: true
    ## If enabled, must be a string with length > 0
    name: dega
    ## Can be one of none|download|upload|public
    policy: download
    ## Purge if bucket exists already
    purge: false
    ## set versioning for bucket true|false
    # versioning: false

  # environment:
  #   MINIO_PROMETHEUS_AUTH_TYPE: "public"

  metrics:
    # Metrics can not be disabled yet: https://github.com/minio/minio/issues/7493
    serviceMonitor:
      enabled: true
      additionalLabels:
        release: monitoring
      # namespace: dega
      # interval: 30s
      # scrapeTimeout: 10s

imgproxy:
  enabled: false

kratos:
  enabled: false

oathkeeper:
  enabled: false

keto:
  enabled: false

  replicaCount: 1

  image:
    repository: oryd/keto
    pullPolicy: IfNotPresent
    # Overrides the image tag whose default is the chart appVersion.
    tag: ""

  imagePullSecrets: []
  nameOverride: ""
  fullnameOverride: ""

  serviceAccount:
    # Specifies whether a service account should be created
    create: false
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  podAnnotations: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  service:
    type: ClusterIP
    port: 4456

  keto:
    # https://www.ory.sh/keto/docs/reference/configuration
    config:
      serve:
        port: 4456

    autoMigrate: false

  ingress:
    enabled: false
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    hosts:
      - host: chart-example.local
        paths: []
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 10
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80

  nodeSelector: {}

  extraenv: {}

  # Configuration for tracing providers. Only datadog is currently supported through this block.
  # If you need to use a different tracing provider, please manually set the configuration values
  # via "keto.config" or via "extraEnv".
  tracing:
    datadog:
      enabled: false

      # Sets the datadog DD_ENV environment variable. This value indicates the environment where keto is running.
      # Default value: "none".
      # env: production

      # Sets the datadog DD_VERSION environment variable. This value indicates the version that keto is running.
      # Default value: .Chart.AppVersion (i.e. the tag used for the docker image).
      # version: X.Y.Z

      # Sets the datadog DD_SERVICE environment variable. This value indicates the name of the service running.
      # Default value: "ory/keto".
      # service: ory/keto

      # Sets the datadog DD_AGENT_HOST environment variable. This value indicates the host address of the datadog agent.
      # If set to true, this configuration will automatically set DD_AGENT_HOST to the field "status.hostIP" of the pod.
      # Default value: false.
      # useHostIP: true

  tolerations: []

  secret: {}

  affinity: {}  

companion:
  enabled: false